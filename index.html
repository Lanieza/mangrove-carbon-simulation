<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mangrove-Carbon Simulation</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: Arial, sans-serif; background-color: #e0f7fa; }
        .container { display: flex;  align-items: flex-start;}
        .controls, canvas { margin-left: 10px; }
        .legend { display: flex; gap: 5px; margin-bottom: 10px; }
        .legend div { display: flex; align-items: center; gap: 5px; font-size: 16px; }
        .legend i { font-size: 20px; }
        .control-group { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .graph-container {width: 30%; padding-right: 10px;}
        #carbonGraph {border: 1px solid black;background-color: white;}
    </style>
</head>
<body>
    <h1>Mangrove-Carbon Simulation</h1>
    <div class="legend">
        <div><i class="fas fa-circle" style="color:#050605;"></i> Carbon</div>
        <div><i class="fas fa-tree" style="color:#4CAF50;"></i> Mangrove</div>
        <div>
            <canvas id="carLegend" width="30" height="35"></canvas> Vehicles
        </div>
        <div><i class="fas fa-home" style="color:#FF9800;"></i> Houses</div>
        <div><i class="fas fa-industry" style="color:#9E9E9E;"></i> Buildings</div>
        <div>
            <canvas id="peopleLegend" width="30" height="30"></canvas> Population
        </div>
    </div>    
    <div class="container">
        <!-- Left side: Carbon Graph -->
        <div class="graph-container">
            <canvas id="carbonGraph" width="400" height="300"></canvas>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Mangroves: <span id="mangrovesValue">0</span></label>
                <input type="range" id="mangrove" min="0" max="100" value="0" oninput="updateSimulation()">
            </div>
            <div class="control-group">
                <label>Sea Temperature: <span id="seaTempValue">0</span>Â°C</label>
                <input type="range" id="temp" min="20" max="25" value="0" oninput="updateSimulation()">
            </div>
            <div class="control-group">
                <label>Vehicles: <span id="vehiclesValue">0</span></label>
                <input type="range" id="vehicles" min="0" max="25" value="0" oninput="updateSimulation()">
            </div>
            <div class="control-group">
                <label>Houses: <span id="housesValue">0</span></label>
                <input type="range" id="houses" min="0" max="25" value="0" oninput="updateSimulation()">
            </div>
            <div class="control-group">
                <label>Buildings: <span id="buildingsValue">0</span></label>
                <input type="range" id="buildings" min="0" max="25" value="0" oninput="updateSimulation()">
            </div>
            <div class="control-group">
                <label>Population: <span id="peopleValue">0</span></label>
                <input type="range" id="population" min="0" max="25" value="0" oninput="updateSimulation()">
            </div>
        </div>
        <canvas id="simulationCanvas" width="1200" height="650" style="border: 1px solid black;"></canvas>
        
    </div>
    <!-- <canvas id="carbonGraph" width="600" height="300"></canvas> -->
    
    <script>

        const simCanvas = document.getElementById('simulationCanvas');
        const simCtx = simCanvas.getContext('2d');

        const ctx = document.getElementById("carbonGraph").getContext("2d");
        // Initial Carbon and Mangrove Data
        let years = ["Year 1", "Year 2", "Year 3", "Year 4", "Year 5", "Year 6"];
        let carbonData = [200, 180, 160, 140, 120, 100];  // Initial carbon values
        
        // Create Chart.js Graph
        let carbonChart = new Chart(ctx, {
            type: "line",
            data: {
                labels: years,
                datasets: [
                    {
                        label: "Atmospheric Carbon (ppm)",
                        data: carbonData,
                        borderColor: "red",
                        borderWidth: 2,
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        title: { display: true, text: "Years" }
                    },
                    y: {
                        title: { display: true, text: "Carbon Level (ppm)" },
                        beginAtZero: false
                    }
                }
            }
        });

        document.querySelectorAll('input').forEach(input => input.addEventListener('input', updateSimulation));

        let carbonParticles = [];
        //Updating Simulations
        function updateSimulation() {
            simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);
            
            let temp = parseFloat(document.getElementById('temp').value) || 0;
            let mangrove = parseFloat(document.getElementById('mangrove').value) || 0;
            let vehicles = parseFloat(document.getElementById('vehicles').value) || 0;
            let houses = parseFloat(document.getElementById('houses').value) || 0;
            let buildings = parseFloat(document.getElementById('buildings').value) || 0;
            let population = parseFloat(document.getElementById('population').value) || 0;
            
            // Update the global sea temperature variable
            seaTemp = temp;
            drawSea();
            drawRoad();

            // Generate Carbon Emissions
            generateCarbonParticles(vehicles, houses, buildings, population, temp);
            
            // **Mangroves Reduce Carbon**
            absorbCarbonWithMangroves();
            // drawAbsorptionEffect(); // Show the fun green bubbles!

             // Start Carbon Level
            let initialCarbon = 300;  
            carbonData[0] = initialCarbon;
            
             // Simulate Carbon Change Over 6 Years (Bigger effect for kids to see)
            for (let i = 1; i < carbonData.length; i++) {
                let previousCarbon = carbonData[i - 1];

                // Carbon increase from human activity
                let emissionIncrease = (vehicles * 3) + (buildings * 4) + (houses * 2) + (population * 2) + ((temp - 20) * 5);

                // Carbon absorption from mangroves
                let absorption = mangrove * 5; // Bigger impact to make it noticeable for kids

                // New carbon level (simplified)
                carbonData[i] = previousCarbon + emissionIncrease - absorption;

                // Keep carbon within a kid-friendly range
                if (carbonData[i] < 100) {
                    carbonData[i] = 100; // Minimum safe level
                }
                if (carbonData[i] > 600) {
                    carbonData[i] = 600; // Maximum danger level
                }
            }

            // **Color the graph based on danger level**
            let graphColor = "green"; // Default = good
            if (carbonData[5] > 400) graphColor = "red"; // Bad carbon level
            else if (carbonData[5] > 300) graphColor = "orange"; // Medium

            // Update Graph Colors
            carbonChart.data.datasets[0].data = carbonData;
            carbonChart.data.datasets[0].borderColor = graphColor;
            carbonChart.update();

            // draw building
            initializeBuilding(buildings);
            drawBuilding(simCtx);

            // Draw houses
            initializeHouses(houses);
            drawHouses(simCtx);


            //draw people
            initializePeople(population);
            drawPeople(simCtx);

            // Draw mangroves
            initializeMangroves(mangrove);
            drawMangroves(simCtx);

            //draw car
            makeCar(vehicles);

            // Draw carbon emissions
            drawCarbonParticles();
        }

        function absorbCarbonWithMangroves() {
    let absorptionRadius = 50; // Radius around mangroves that absorbs carbon

    // **Draw Green Glow to Show Absorption Area**
    mangrovePositions.forEach(mangrove => {
        simCtx.fillStyle = "rgba(0, 255, 0, 0.3)";
        simCtx.beginPath();
        simCtx.arc(mangrove.x, mangrove.y, absorptionRadius, 0, Math.PI * 2);
        simCtx.fill();
    });

    // **Filter Carbon Particles That Are Outside the Absorption Area**
    carbonParticles = carbonParticles.filter(particle => {
        let absorbed = mangrovePositions.some(mangrove => {
            let dx = particle.x - mangrove.x;
            let dy = particle.y - mangrove.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            return distance < absorptionRadius; // If inside radius, mark for removal
        });

        return !absorbed; // Keep only particles NOT absorbed
    });

    console.log("Carbon Particles After Absorption:", carbonParticles.length); // Debugging
}

        function absorbCarbonWithMangroves() {
            let baseAbsorption = 2; // Each mangrove absorbs 2 particles per second (kid-friendly speed)
            let totalAbsorption = mangrovePositions.length * baseAbsorption;

            // **Show a Green Glow Around Mangroves**
            mangrovePositions.forEach(mangrove => {
                simCtx.fillStyle = "rgba(0, 255, 0, 0.3)";
                simCtx.beginPath();
                simCtx.arc(mangrove.x, mangrove.y, 50, 0, Math.PI * 2);
                simCtx.fill();
            });

            // **Gradual Absorption - Only Absorb Some Carbon Each Frame**
            let maxAbsorption = Math.min(totalAbsorption, carbonParticles.length * 0.15); // Up to 15% per frame
            carbonParticles = carbonParticles.slice(maxAbsorption); // Remove absorbed particles

            // **Add a Fun "Bubble Effect" When Carbon is Absorbed**
            for (let i = 0; i < maxAbsorption; i++) {
                let x = Math.random() * simCanvas.width; 
                let y = Math.random() * simCanvas.height;
                absorptionBubbles.push({ x, y, size: Math.random() * 5 + 3, opacity: 1 });
            }

            console.log(`Carbon Particles Left: ${carbonParticles.length}`);
        }

        let absorptionBubbles = []; // Stores "bubbles" from absorbed carbon

        function drawAbsorptionEffect() {
            simCtx.fillStyle = "rgba(0, 255, 0, 0.5)"; // Green bubbles

            absorptionBubbles.forEach((bubble, index) => {
                simCtx.globalAlpha = bubble.opacity;
                simCtx.beginPath();
                simCtx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                simCtx.fill();
                bubble.y -= 0.5; // Move bubbles up
                bubble.opacity -= 0.01; // Slowly fade out

                if (bubble.opacity <= 0) {
                    absorptionBubbles.splice(index, 1); // Remove when fully faded
                }
            });

            simCtx.globalAlpha = 1; // Reset opacity for other drawings
        }

        function generateCarbonParticles(vehicles, houses, buildings, population, temp) {
            let mangroveFactor = Math.max(1 - mangrovePositions.length / 100, 0.1); // Reduce emissions if mangroves exist

            let emissionLevels = {
                vehicles: Math.ceil(3 * mangroveFactor),  // Reduce based on mangroves
                houses: Math.ceil(1 * mangroveFactor),
                buildings: Math.ceil(2 * mangroveFactor),
                population: Math.ceil(1 * mangroveFactor),
                seaTemp: Math.ceil((temp - 20) * 1.5 * mangroveFactor)
            };

            // **Generate Carbon Emissions with Reduced Effect**
            carPositions.forEach(car => {
                for (let i = 0; i < emissionLevels.vehicles; i++) {
                    carbonParticles.push(createCarbonParticle(car.x + 10, car.y));
                }
            });

            buildingPositions.forEach(building => {
                for (let i = 0; i < emissionLevels.buildings; i++) {
                    carbonParticles.push(createCarbonParticle(building.x + 20, building.y));
                }
            });

            housePositions.forEach(house => {
                for (let i = 0; i < emissionLevels.houses; i++) {
                    carbonParticles.push(createCarbonParticle(house.x + 15, house.y));
                }
            });

            peoplePositions.forEach(person => {
                for (let i = 0; i < emissionLevels.population; i++) {
                    carbonParticles.push(createCarbonParticle(person.x, person.y));
                }
            });

            if (temp > 22) {
                for (let i = 0; i < emissionLevels.seaTemp; i++) {
                    carbonParticles.push(createCarbonParticle(
                        Math.random() * (simCanvas.width * 0.35), 
                        simCanvas.height - 5
                    ));
                }
            }
        }

        function createCarbonParticle(x, y) {
            return {
                x: x,
                y: y,
                size: Math.random() * 4 + 2, // Random size between 2-6 pixels
                speed: Math.random() * 0.5 + 0.3, // Slower, smooth floating
                opacity: 1, // Start fully visible
                drift: Math.random() * 2 - 1, // Slight left-right movement
                curve: Math.random() * 0.05 // Creates a gentle wave effect
            };
        }


        function drawCarbonParticles() {
            if (!carbonParticles || carbonParticles.length === 0) return;

            simCtx.fillStyle = "rgba(50, 50, 50, 0.8)"; // Dark gray for carbon particles

            carbonParticles.forEach((particle, index) => {
                simCtx.globalAlpha = particle.opacity; // Smooth fade-out effect

                // **Draw carbon particle**
                simCtx.beginPath();
                simCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                simCtx.fill();

                // **Smooth floating animation**
                particle.y -= particle.speed; // Move up slowly
                particle.x += Math.sin(particle.y * particle.curve) * 0.5; // Gentle drifting
                particle.opacity -= 0.005; // Slow fade-out

                // **Remove fully faded particles**
                if (particle.opacity <= 0) {
                    carbonParticles.splice(index, 1);
                }
            });

            simCtx.globalAlpha = 1; // Reset opacity for other drawings
}


        //draw mangroves
        let mangrovePositions = [];
        let waveOffsetMangrove = 0; // To animate the movement

        // Initialize Mangroves
        function initializeMangroves(mangrove) {
            let count = Math.floor(mangrove / 1); // Adjust density
            if (mangrovePositions.length !== count) {
                generateMangrovePositions(count);
            }
        }
        
        function drawMangroves(ctx) {
            mangrovePositions.forEach(mangrove => {
                drawMangroveTree(ctx, mangrove.x, mangrove.y);
            });
        }

        // Generate random positions for mangroves in the sea only
        function generateMangrovePositions(count) {
            mangrovePositions = []; // Reset the list
            let seaX = 120; // Start at leftmost part of the sea
            let seaWidth = simCanvas.width * 0.25; // Mangroves can only be in 40% of canvas
            let mangroveSize = 20; // Size of each mangrove
            let buffer = 0; // Prevent overlap
            let maxAttempts = 100; // Avoid infinite loops

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newMangrove;
                let collision;

                do {
                    let mangroveX = seaX + Math.random() * (seaWidth - mangroveSize);
                    let mangroveY = Math.random() * (simCanvas.height - mangroveSize);

                    newMangrove = { x: mangroveX, y: mangroveY };

                    // Check for collision with other mangroves
                    collision = mangrovePositions.some(mangrove => 
                        checkCollision(mangrove, newMangrove, mangroveSize, mangroveSize, buffer)
                    );

                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    mangrovePositions.push(newMangrove);
                }
            }
        }


        // Draw a **realistic mangrove tree**
        function drawMangroveTree(ctx, x, y) {
            let treeHeight = 40;
            let trunkWidth = 5;
            let canopyRadius = 18;

            // Animate sway effect
            let sway = Math.sin(waveOffsetMangrove * 0.1) * 3; // Slight movement effect

            // **Draw roots**
            ctx.strokeStyle = "brown";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y + treeHeight); // Base of trunk
            ctx.lineTo(x - 5, y + treeHeight + 10 + sway);
            ctx.moveTo(x, y + treeHeight);
            ctx.lineTo(x + 5, y + treeHeight + 12 - sway);
            ctx.stroke();

            // **Draw trunk**
            ctx.fillStyle = "brown";
            ctx.fillRect(x - trunkWidth / 2, y, trunkWidth, treeHeight);

            // **Draw canopy (green swaying leaves)**
            ctx.fillStyle = "#2E8B57"; // Dark green
            ctx.beginPath();
            ctx.arc(x + sway, y - 10, canopyRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#4CAF50"; // Lighter green for depth
            ctx.beginPath();
            ctx.arc(x - 5 + sway, y - 12, canopyRadius * 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        // **Animate Mangroves**
        function animateMangroves() {
            waveOffsetMangrove += 1; // Move the wave effect
            requestAnimationFrame(animateMangroves); // Loop animation
        }

        // Start animation loop for mangroves
        animateMangroves();

        //draw building
        let buildingPositions = [];
        function initializeBuilding(buildings) {
            let count = Math.floor(buildings / 2);
            if (buildingPositions.length !== count) {
                generateBuildingPositions(count);
            }
        }

        function drawBuilding(ctx) {
            buildingPositions.forEach(building => {
                let buildingWidth = 40; // Smaller width
                let buildingHeight = 120; // Smaller height

                // Draw building body
                ctx.fillStyle = "gray";
                ctx.fillRect(building.x, building.y, buildingWidth, buildingHeight);
                
                // Draw building outline
                ctx.strokeStyle = "black";
                ctx.lineWidth = 3;
                ctx.strokeRect(building.x, building.y, buildingWidth, buildingHeight);

                // Draw windows
                ctx.fillStyle = "lightblue"; // Window color
                let windowWidth = 10, windowHeight = 10;
                let gapX = 5, gapY = 15; // Spacing for windows

                for (let row = 0; row < 3; row++) { // 3 rows of windows
                    for (let col = 0; col < 2; col++) { // 2 columns of windows
                        let windowX = building.x + gapX + col * (windowWidth + 10);
                        let windowY = building.y + gapY + row * (windowHeight + 15);
                        ctx.fillRect(windowX, windowY, windowWidth, windowHeight);
                        ctx.strokeRect(windowX, windowY, windowWidth, windowHeight); // Outline for window
                    }
                }

                // Draw door
                ctx.fillStyle = "brown";
                let doorWidth = 15, doorHeight = 25;
                let doorX = building.x + (buildingWidth - doorWidth) / 2; // Center door
                let doorY = building.y + buildingHeight - doorHeight;
                ctx.fillRect(doorX, doorY, doorWidth, doorHeight);
                ctx.strokeRect(doorX, doorY, doorWidth, doorHeight); // Outline for door
            });
        }

        function generateBuildingPositions(count) {
            buildingPositions = []; // Reset list
            let landX = (simCanvas.width - 200) / 2 + 200; // Land starts here
            let landWidth = simCanvas.width - landX;
            let buildingWidth = 40;  
            let buildingHeight = 120; 
            let buffer = 20; // Avoid overlap
            let maxAttempts = 100;

            let landY = 50; // Ensure buildings start higher up
            let landHeight = simCanvas.height - landY - buildingHeight - buffer; 

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newBuilding;
                let collision;

                do {
                    let buildingX = landX + Math.random() * (landWidth - buildingWidth - buffer);
                    let buildingY = landY + Math.random() * (landHeight - buffer); // Spread across land

                    newBuilding = { x: buildingX, y: buildingY };

                    // Check for collision with other buildings
                    collision = buildingPositions.some(building => 
                        checkBuildingCollision(building, newBuilding, buildingWidth, buildingHeight, buffer)
                    );

                    // Check for collision with houses
                    if (!collision) {
                        collision = housePositions.some(house => 
                            checkBuildingCollision(house, newBuilding, buildingWidth, buildingHeight, buffer)
                        );
                    }

                    // Check for collision with people
                    if (!collision) {
                        collision = peoplePositions.some(person =>
                            checkCollision(person, newBuilding, buildingWidth, buildingHeight, buffer)
                        );
                    }

                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    buildingPositions.push(newBuilding);
                }
            }

            buildingPositions.length = count; // Trim extra buildings if count is reduced
        }

        function checkBuildingCollision(a, b, width, height, buffer) {
            return (
                a.x < b.x + width + buffer &&
                a.x + width + buffer > b.x &&
                a.y < b.y + height + buffer &&
                a.y + height + buffer > b.y
            );
        }

        // Draw houses
        function drawHouses(ctx) {
            housePositions.forEach(house => {
                let houseWidth = 40;
                let houseHeight = 30;
                let roofHeight = 20;
                let brickSize = 6;

                // House Body (Brick Wall)
                ctx.fillStyle = "#FF9800";
                ctx.fillRect(house.x, house.y, houseWidth, houseHeight);

                // Draw bricks
                ctx.strokeStyle = "#D2691E";
                ctx.lineWidth = 2;
                for (let y = house.y; y < house.y + houseHeight; y += brickSize) {
                    for (let x = house.x; x < house.x + houseWidth; x += brickSize) {
                        let offset = (y % (brickSize * 2) === 0) ? 0 : brickSize / 2 - 4;
                        ctx.strokeRect(x + offset, y, brickSize, brickSize);
                    }
                }

                // Outline for the house
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.strokeRect(house.x, house.y, houseWidth, houseHeight);

                // Roof
                ctx.fillStyle = "#D84315";
                ctx.beginPath();
                ctx.moveTo(house.x, house.y);
                ctx.lineTo(house.x + houseWidth / 2, house.y - roofHeight);
                ctx.lineTo(house.x + houseWidth, house.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Windows
                ctx.fillStyle = "#ADD8E6"; // Light blue glass effect
                let windowSize = 8;
                let windowSpacing = 6;
                ctx.fillRect(house.x + windowSpacing, house.y + 5, windowSize, windowSize);
                ctx.fillRect(house.x + houseWidth - windowSpacing - windowSize, house.y + 5, windowSize, windowSize);
                ctx.strokeRect(house.x + windowSpacing, house.y + 5, windowSize, windowSize);
                ctx.strokeRect(house.x + houseWidth - windowSpacing - windowSize, house.y + 5, windowSize, windowSize);

                // Door
                ctx.fillStyle = "brown";
                let doorWidth = 10, doorHeight = 15;
                let doorX = house.x + (houseWidth - doorWidth) / 2;
                let doorY = house.y + houseHeight - doorHeight;
                ctx.fillRect(doorX, doorY, doorWidth, doorHeight);
                ctx.strokeRect(doorX, doorY, doorWidth, doorHeight);

                // Doorknob
                ctx.fillStyle = "gold";
                ctx.beginPath();
                ctx.arc(doorX + doorWidth - 2, doorY + doorHeight / 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        let housePositions = [];
        // Initialize houses
        function initializeHouses(houses) {
            let count = Math.floor(houses / 2); // Adjust density
            if (housePositions.length !== count) {
                generateHousePositions(count);
            }
        }

        function generateHousePositions(count) {
            housePositions = []; // Reset list
            let landX = (simCanvas.width - 200) / 2 + 150; // Land starts here
            let landWidth = simCanvas.width - landX;
            let houseWidth = 40, houseHeight = 30;
            let buffer = 20; // Avoid overlap
            let maxAttempts = 100;

            let landY = 50; // Start higher to cover more land
            let landHeight = simCanvas.height - landY - houseHeight - buffer; 

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newHouse;
                let collision;

                do {
                    let houseX = landX + Math.random() * (landWidth - houseWidth - buffer);
                    let houseY = landY + Math.random() * (landHeight - buffer); // Spread across land

                    newHouse = { x: houseX, y: houseY };

                    // Check for collision with other houses
                    collision = housePositions.some(house =>
                        checkCollision(house, newHouse, houseWidth, houseHeight, buffer)
                    );

                    // Check for collision with buildings
                    if (!collision) {
                        collision = buildingPositions.some(building =>
                            checkCollision(building, newHouse, 40, 120, buffer)
                        );
                    }

                    // Check for collision with people
                    if (!collision) {
                        collision = peoplePositions.some(person =>
                            checkCollision(person, newHouse, houseWidth, houseHeight, buffer)
                        );
                    }

                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    housePositions.push(newHouse);
                }
            }
        }
        
        // draw People
        // Call this once when population changes, NOT in updateSimulation
        function initializePeople(population) {
            let count = Math.floor(population / 2);
            if (peoplePositions.length !== count) {
                generatePeoplePositions(count);
            }
        }

        function drawPeople(ctx) {
            peoplePositions.forEach(person => {
                // Draw Head (Circle)
                ctx.fillStyle = person.headColor;
                ctx.beginPath();
                ctx.arc(person.x, person.y, 5, 0, Math.PI * 2);
                ctx.fill();

                // Draw Body (Rectangle)
                ctx.fillStyle = person.shirtColor;
                ctx.fillRect(person.x - 5, person.y + 10, 10, 15);

                // Draw Legs (Two small rectangles)
                ctx.fillStyle = person.pantsColor;
                ctx.fillRect(person.x - 5, person.y + 25, 4, 10);
                ctx.fillRect(person.x + 1, person.y + 25, 4, 10);
            });
        }

        let peoplePositions = [];

        function generatePeoplePositions(count) {
            peoplePositions = []; // Reset list
            let landX = (simCanvas.width - 200) / 2 + 150; // Land starts here
            let landWidth = simCanvas.width - landX;
            let personSize = 20;
            let buffer = 15; // Avoid overlap
            let maxAttempts = 100;

            // Define color options
            const headColors = ["#FDD835", "#FFCCBC", "#FFC107", "#D4A373"];
            const shirtColors = ["#9C27B0", "#1976D2", "#388E3C", "#FF5722", "#E91E63"];
            const pantsColors = ["black", "navy", "gray", "brown", "#795548"];


            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newPerson;
                let collision;

                do {
                    let personX = landX + Math.random() * (landWidth - personSize);
                    let personY = Math.random() * (simCanvas.height - personSize);
                    newPerson = { x: personX, y: personY };

                    // Assign random colors **once** when generating the person
                    let headColor = headColors[Math.floor(Math.random() * headColors.length)];
                    let shirtColor = shirtColors[Math.floor(Math.random() * shirtColors.length)];
                    let pantsColor = pantsColors[Math.floor(Math.random() * pantsColors.length)];
                    
                    newPerson = { 
                        x: personX, 
                        y: personY,
                        headColor: headColor, 
                        shirtColor: shirtColor, 
                        pantsColor: pantsColor 
                    };

                    // Check collision with other people
                    collision = peoplePositions.some(person => 
                        checkCollision(person, newPerson, personSize, personSize, buffer)
                    );

                    // Check collision with buildings
                    if (!collision) {
                        collision = buildingPositions.some(building => 
                            checkCollision(
                                building, 
                                newPerson, 
                                40, // Building width
                                120, // Building height
                                buffer
                            )
                        );
                    }

                    // Check collision with houses
                    if (!collision) {
                        collision = housePositions.some(house => 
                            checkCollision(
                                house, 
                                newPerson, 
                                40, // House width (assuming it's the same as in generateHousePositions)
                                30, // House height
                                buffer
                            )
                        );
                    }

                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    peoplePositions.push(newPerson);
                }
            }
        }

        // **Generalized function to check collisions between two rectangular objects**
        function checkCollision(obj1, obj2, obj1Width, obj1Height, buffer) {
            return (
                obj1.x < obj2.x + obj1Width + buffer &&
                obj1.x + obj1Width + buffer > obj2.x &&
                obj1.y < obj2.y + obj1Height + buffer &&
                obj1.y + obj1Height + buffer > obj2.y
            );
        }
                
        //check collision for people only 
        function checkPersonCollision(person1, person2, width, height, buffer) {
            return (
                person1.x < person2.x + width + buffer &&
                person1.x + width + buffer > person2.x &&
                person1.y < person2.y + height + buffer &&
                person1.y + height + buffer > person2.y
            );
        }

        // Call initializePeople() once at the start or when population changes
        initializePeople();

        //draw road
        function drawRoad(){
            // Draw Road (Centered)
            simCtx.fillStyle = "#707070";
            let roadWidth = 120;
            let roadX = (simCanvas.width - roadWidth) / 2 - 50;
            simCtx.fillRect(roadX, 0, roadWidth, simCanvas.height);

            // Draw Lane Markings
            simCtx.strokeStyle = "white";
            simCtx.lineWidth = 5;
            simCtx.setLineDash([20, 20]); // Dashed lines
            simCtx.beginPath();
            simCtx.moveTo(roadX + roadWidth / 2, 0);
            simCtx.lineTo(roadX + roadWidth / 2, simCanvas.height);
            simCtx.stroke();
            simCtx.setLineDash([]); // Reset dash style

            // Draw Land (On Top of Road, Right Side)
            simCtx.fillStyle = "#CD853F"; // Brown for land
            let landX = roadX + roadWidth; // Right side of the road
            simCtx.fillRect(landX, 0, simCanvas.width - landX, simCanvas.height);
        }

        //draw car
        function makeCar(vehicles){
            //draw car and initialization of car/vehicle only
            let carCount = Math.floor(vehicles / 2); // Adjust density
            if (carPositions.length !== carCount) {
                generateCarPositions(carCount); // Only update when needed
            }
            carPositions.forEach(car => drawCar(simCtx, car.x, car.y, car.color));
        }

        function drawCar(ctx, x, y, color) { 
            let carWidth = 20;  // Smaller width
            let carHeight = 35; // Smaller height

            // Draw car body
            ctx.fillStyle = color;
            ctx.fillRect(x, y, carWidth, carHeight);  

            // Draw car outline
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, carWidth, carHeight);

            // Roof (Windows Area)
            ctx.fillStyle = "lightblue";
            ctx.fillRect(x + 4, y + 6, carWidth - 8, carHeight - 18);
            ctx.strokeRect(x + 4, y + 6, carWidth - 8, carHeight - 18); // Outline for windows

            // Wheels (Smaller)
            ctx.fillStyle = "black";
            ctx.fillRect(x - 2, y + 2, 5, 8);   // Front-left wheel
            ctx.fillRect(x + carWidth - 3, y + 2, 5, 8);  // Front-right wheel
            ctx.fillRect(x - 2, y + carHeight - 10, 5, 8);  // Rear-left wheel
            ctx.fillRect(x + carWidth - 3, y + carHeight - 10, 5, 8);  // Rear-right wheel

            // Headlights (Front)
            ctx.fillStyle = "yellow";
            ctx.fillRect(x + 5, y - 2, 10, 2);
            ctx.strokeRect(x + 5, y - 2, 10, 2); // Outline for headlights

            // Taillights (Rear)
            ctx.fillStyle = "red";
            ctx.fillRect(x + 5, y + carHeight, 10, 2);
            ctx.strokeRect(x + 5, y + carHeight, 10, 2); // Outline for taillights
        }

        let carPositions = []; // Store car positions
        function generateCarPositions(count) {
            carPositions = []; // Reset the car list
            let roadX = (simCanvas.width - 200) / 2 - 10;
            let roadWidth = 130;
            let carWidth = 30;
            let carHeight = 50;
            let buffer = 10; // Extra space to prevent collisions
            let maxAttempts = 100; // Prevent infinite loops
            let carColors = ["blue", "red"];

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newCar;
                let collision;

                do {
                    let carX = roadX + Math.random() * (roadWidth - carWidth);
                    let carY = Math.random() * (simCanvas.height - carHeight);
                    let color = carColors[Math.floor(Math.random() * carColors.length)];
                    newCar = { x: carX, y: carY, color: color };
                    collision = carPositions.some(car => checkCarCollision(car, newCar, carWidth, carHeight, buffer));
                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    carPositions.push(newCar);
                }
            }
        }

        function checkCarCollision(car1, car2, carWidth, carHeight, buffer = 0) {
            return (
                car1.x < car2.x + carWidth + buffer &&
                car1.x + carWidth + buffer > car2.x &&
                car1.y < car2.y + carHeight + buffer &&
                car1.y + carHeight + buffer > car2.y
            );
        }

        //sea drawing
        let waveOffset = 0;
        let smallWaves = [];
        let heatBubbles = [];

        function drawSea() {
            // **Get current sea temperature from the slider**
            seaTemp = parseFloat(document.getElementById('temp').value) || 20;

            // **Adjust sea color dynamically**
            let blueTone = Math.max(150, 213 - (seaTemp - 20) * 10); // Cooler sea = lighter, hotter = darker
            let seaColor = `rgb(${Math.min(163 + (seaTemp - 20) * 5, 255)}, ${blueTone}, 255)`;
            simCtx.fillStyle = seaColor;
            simCtx.fillRect(0, 0, simCanvas.width * 0.4, simCanvas.height);

            // **Wave Motion Settings**
            let amplitude = 15 + (seaTemp - 20) * 3; // Higher temp = stronger waves
            let frequency = 0.02;
            let numWaves = 5;

            // **Main Wave Effect**
            simCtx.fillStyle = '#4da6ff';
            simCtx.beginPath();
            for (let i = 0; i < numWaves; i++) {
                let phase = i * Math.PI / numWaves;
                simCtx.moveTo(0, 0);
                for (let y = 0; y <= simCanvas.height; y += 5) {
                    let waveX = Math.sin((y + waveOffset + phase) * frequency) * amplitude + 100;
                    simCtx.lineTo(waveX, y);
                }
                simCtx.lineTo(0, simCanvas.height);
            }
            simCtx.closePath();
            simCtx.fill();

            // **Small Random Waves Near Shore**
            simCtx.fillStyle = '#ffffff'; // White for foam effect
            smallWaves.forEach((wave, index) => {
                simCtx.beginPath();
                simCtx.arc(wave.x, wave.y, wave.size, 0, Math.PI * 2);
                simCtx.fill();
                wave.x += wave.speed; // Move toward shore
                wave.y += Math.sin(waveOffset * 0.1) * 0.5;

                // Remove wave if it reaches shoreline
                if (wave.x > simCanvas.width * 0.3) {
                    smallWaves.splice(index, 1);
                }
            });

            // **Generate Tiny Waves Randomly**
            if (Math.random() < 0.02) {
                smallWaves.push({
                    x: simCanvas.width * 0.2,
                    y: Math.random() * simCanvas.height,
                    size: Math.random() * 4 + 2, // Tiny wave size
                    speed: Math.random() * 0.8 + 0.3 // Random speed
                });
            }

            // **Heat Bubble Effect for Warmer Oceans**
            if (seaTemp > 22) {
                simCtx.fillStyle = `rgba(255, 69, 0, ${(seaTemp - 22) * 0.1})`; // Orange bubbles for heat
                heatBubbles.forEach((bubble, index) => {
                    simCtx.beginPath();
                    simCtx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);
                    simCtx.fill();
                    bubble.y -= bubble.speed; // Move bubbles up

                    if (bubble.y < 0) {
                        heatBubbles.splice(index, 1); // Remove bubbles above surface
                    }
                });

                // Generate bubbles more frequently when temperature is high
                if (Math.random() < (seaTemp - 22) * 0.02) {
                    heatBubbles.push({
                        x: Math.random() * (simCanvas.width * 0.4),
                        y: simCanvas.height - 10,
                        size: Math.random() * 4 + 2,
                        speed: Math.random() * 0.5 + 0.2
                    });
                }
            }

            waveOffset += 1; // Animate waves

            // **Draw Shoreline LAST so it's always on top**
            drawShoreline();
        }

        function drawShoreline() {
            // **Fixed Shoreline Color (Does NOT change with temperature)**
            simCtx.fillStyle = '#c2a772'; // Permanent sand color

            simCtx.beginPath();
            for (let y = 0; y <= simCanvas.height; y += 10) {
                let shorelineX = simCanvas.width * 0.26 + Math.sin((y + waveOffset) * 0.02) * 8 + 100;
                simCtx.lineTo(shorelineX, y);
            }
            simCtx.lineTo(simCanvas.width * 15, simCanvas.height);
            simCtx.lineTo(simCanvas.width * 0.4, 0);
            simCtx.closePath();
            simCtx.fill();
        }

        function animate() {
            waveOffset += 1; // Move the wave
            updateSimulation(); // Redraw the whole simulation
            requestAnimationFrame(animate); // Loop animation
        }

        // Start animation loop for sea waves
        animate();

        //Drawing Legend
        function drawLegendCar() {
            let canvas = document.getElementById("carLegend");
            let ctx = canvas.getContext("2d");

            ctx.fillStyle = "blue"; // Car body color
            ctx.fillRect(5, 10, 15, 20); // Car body

            ctx.fillStyle = "lightgray"; // Car body color
            ctx.fillRect(8, 14, 9, 12); // Car body

            ctx.fillStyle = "black"; // Wheels
            ctx.fillRect(1, 24, 3, 3); // Left wheel
            ctx.fillRect(21, 24, 3, 3); // Right wheel

            ctx.fillRect(1, 12, 3, 3); // Left wheel
            ctx.fillRect(21, 12, 3, 3); // Right wheel

            ctx.fillStyle = "red"; // Car body color
            ctx.fillRect(8, 30, 8, 3); // Car body

            ctx.fillStyle = "yellow"; // Car body color
            ctx.fillRect(8, 7, 8, 3); // Car body

        }

        function drawLegendPerson() {
            let canvas = document.getElementById("peopleLegend");
            let ctx = canvas.getContext("2d");

            ctx.fillStyle = "#FDD835"; // Head
            ctx.beginPath();
            ctx.arc(15, 8, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#9C27B0"; // Body
            ctx.fillRect(12, 13, 6, 10);

            ctx.fillStyle = "black"; // Legs
            ctx.fillRect(12, 23, 2, 5);
            ctx.fillRect(16, 23, 2, 5);
        }

        updateSimulation();
    </script>
</body>
</html>