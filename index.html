<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mangrove-Carbon Simulation</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {display: flex; flex-direction: column; align-items: center; font-family: Arial, sans-serif; background-color: #e0f7fa; }
        .container {
            display: flex;
            align-items: flex-start;
            width: 1500px; /* Set the desired width */
            max-width: 100%; /* Prevent overflow */
            /* border: 1px solid red; (Optional) Add a border to see the effect */
            justify-content: space-between;
        }
        .controls, canvas { margin-left: 10px; }
        .legend { display: flex; gap: 5px; margin-bottom: 10px; }
        .legend div { display: flex; align-items: center; gap: 2px; font-size: 16px; }
        .legend i { font-size: 20px; }
        .control-group { display: flex; align-items: center; gap: 1px; margin-bottom: 1px; }
        .graph-container {width: 100%;} 
        #carbonGraph {border: 1px solid black;background-color: white; margin-top: 2rem;}
        .temp-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            margin-left: 100px;
            width: 80%;
        }

        .temp-slider-container {
            position: relative;
            width: 300px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Temperature gradient background */
        .temp-gradient {
            position: absolute;
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(to right, blue, lightblue, yellow, orange, red);
        }

        /* Temperature slider */
        #temp {
            position: relative;
            width: 100%;
            appearance: none;
            background: transparent;
            cursor: pointer;
            z-index: 2;
        }

        /* Customize the slider thumb */
        #temp::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background-color: red;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        #temp::-webkit-slider-thumb:hover {
            transform: scale(1.3);
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 350px; /* Adjust this width as needed */
        }

        .control-group label {
            flex: none; /* Prevents label from resizing */
            width: 120px; /* Adjust as needed */
            text-align: right;
            padding-right: 10px;
            white-space: nowrap; /* Prevents wrapping */
        }

        .control-group input {
            flex: 2; /* Ensures sliders take up more space */
        }
    </style>
</head>
<body>
    <h1>Mangrove-Carbon Simulation</h1>
    <div class="legend">
        <div><i class="fas fa-circle" style="color:#050605;"></i> Carbon</div>
        <div><i class="fas fa-tree" style="color:#4CAF50;"></i> Mangrove</div>
        <div>
            <canvas id="carLegend" width="30" height="35"></canvas> Vehicles
        </div>
        <div><i class="fas fa-home" style="color:#FF9800;"></i> Houses</div>
        <div><i class="fas fa-industry" style="color:#9E9E9E;"></i> Buildings</div>
        <div>
            <canvas id="peopleLegend" width="30" height="30"></canvas> Population
        </div>
    </div>    
    <div class="container">
        <!-- Left side: Carbon Graph -->
        <div class="left-part">
            <div class="controls">
                <div class="control-group">
                    <label>Mangroves: <span id="mangrovesValue"></span></label>
                    <input type="range" id="mangrove" min="0" max="100" value="0" oninput="updateSimulation()">
                </div>
                <div class="control-group">
                    <label>Vehicles: <span id="vehiclesValue"></span></label>
                    <input type="range" id="vehicles" min="0" max="10" value="0" oninput="updateSimulation()">
                </div>
                <div class="control-group">
                    <label>Houses: <span id="housesValue"></span></label>
                    <input type="range" id="houses" min="0" max="10" value="0" oninput="updateSimulation()">
                </div>
                <div class="control-group">
                    <label>Buildings: <span id="buildingsValue"></span></label>
                    <input type="range" id="buildings" min="0" max="10" value="0" oninput="updateSimulation()">
                </div>
                <div class="control-group">
                    <label>Population: <span id="peopleValue"></span></label>
                    <input type="range" id="population" min="0" max="10" value="0" oninput="updateSimulation()">
                </div>
            </div>

            <div class="graph-container">
                <canvas id="carbonGraph" width="520" height="352"></canvas>
            </div>
        </div>
        
        <div class="right-part">
            <canvas id="simulationCanvas" width="950" height="500" style="border: 1px solid black;"></canvas>   
            
            <!-- New Temperature Control (Now Below the Canvas) -->
            <div class="temp-control">
                <label>Sea Temperature: <span id="seaTempValue">25</span>Â°C</label>
                <div class="temp-slider-container">
                    <input type="range" id="temp" min="20" max="35" value="25" oninput="updateTemperature()">
                    <div class="temp-gradient"></div>
                </div>
            </div>
        </div>
        
        
    </div>
    
    <script>

        const simCanvas = document.getElementById('simulationCanvas');
        const simCtx = simCanvas.getContext('2d');

        const ctx = document.getElementById("carbonGraph").getContext("2d");
        // Initial Carbon and Mangrove Data
        let years = ["Year 1", "Year 2", "Year 3", "Year 4", "Year 5", "Year 6"];
        let carbonData = [200, 180, 160, 140, 120, 100];  // Initial carbon values
        
        // Create Chart.js Graph
        let carbonChart = new Chart(ctx, {
            type: "line",
            data: {
                labels: years,
                datasets: [
                    {
                        label: "Atmospheric Carbon (ppm)",
                        data: carbonData,
                        borderColor: "red",
                        borderWidth: 2,
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        title: { display: true, text: "Years" }
                    },
                    y: {
                        title: { display: true, text: "Carbon Level (ppm)" },
                        beginAtZero: false
                    }
                }
            }
        });

        document.querySelectorAll('input').forEach(input => input.addEventListener('input', updateSimulation));

        function toggleCarbon() {
            carbonVisible = !carbonVisible;

            let button = document.getElementById("toggleCarbon");
            button.textContent = carbonVisible ? "Hide Carbon" : "Show Carbon";

            updateSimulation(); // Redraw without carbon if turned off
        }
        
        let carbonParticles = [];
        //Updating Simulations
        function updateSimulation() {
            simCtx.clearRect(0, 0, simCanvas.width, simCanvas.height);
            
            let temp = parseFloat(document.getElementById('temp').value) || 0;
            let mangrove = parseFloat(document.getElementById('mangrove').value) || 0;
            let vehicles = parseFloat(document.getElementById('vehicles').value) || 0;
            let houses = parseFloat(document.getElementById('houses').value) || 0;
            let buildings = parseFloat(document.getElementById('buildings').value) || 0;
            let population = parseFloat(document.getElementById('population').value) || 0;
            
            // Update the global sea temperature variable
            seaTemp = temp;
            drawSea();
            drawRoad();
            
            drawCarbonParticles();
            generateCarbonParticles(vehicles, houses, buildings, population, temp);
            //  Mangroves Reduce Carbon 
            absorbCarbonWithMangroves();

             // Start Carbon Level
            let initialCarbon = 300;  
            carbonData[0] = initialCarbon;
            
             // Simulate Carbon Change Over 6 Years (Bigger effect for kids to see)
            for (let i = 1; i < carbonData.length; i++) {
                let previousCarbon = carbonData[i - 1];

                // Carbon increase from human activity
                let emissionIncrease = (vehicles * 3) + (buildings * 4) + (houses * 2) + (population * 2) + ((temp - 20) * 5);

                // Carbon absorption from mangroves
                let absorption = mangrove * 5; // Bigger impact to make it noticeable for kids

                // New carbon level (simplified)
                carbonData[i] = previousCarbon + emissionIncrease - absorption;

                // Keep carbon within a kid-friendly range
                if (carbonData[i] < 100) {
                    carbonData[i] = 100; // Minimum safe level
                }
                if (carbonData[i] > 600) {
                    carbonData[i] = 600; // Maximum danger level
                }
            }

            //  Color the graph based on danger level 
            let graphColor = "green"; // Default = good
            if (carbonData[5] > 400) graphColor = "red"; // Bad carbon level
            else if (carbonData[5] > 300) graphColor = "orange"; // Medium

            // Update Graph Colors
            carbonChart.data.datasets[0].data = carbonData;
            carbonChart.data.datasets[0].borderColor = graphColor;
            carbonChart.update();

            // draw building
            initializeBuilding(buildings);
            drawBuilding(simCtx);

            // Draw houses
            initializeHouses(houses);
            drawHouses(simCtx);


            //draw people
            initializePeople(population);
            drawPeople(simCtx);

            // Draw mangroves
            initializeMangroves(mangrove);
            drawMangroves(simCtx);

            //draw car
            makeCar(vehicles);
            

            //  Update the values displayed next to the sliders 
            document.getElementById('mangrovesValue').innerText = mangrove;
            document.getElementById('vehiclesValue').innerText = vehicles;
            document.getElementById('housesValue').innerText = houses;
            document.getElementById('buildingsValue').innerText = buildings;
            document.getElementById('peopleValue').innerText = population;
        }

        function updateTemperature() {
            let temp = document.getElementById('temp').value;
            document.getElementById('seaTempValue').innerText = temp;

            // Change thumb color based on temperature
            let color;
            if (temp < 23) color = "blue";
            else if (temp < 27) color = "lightblue";
            else if (temp < 30) color = "yellow";
            else if (temp < 33) color = "orange";
            else color = "red";

            document.documentElement.style.setProperty("--slider-thumb-color", color);
        }

        function absorbCarbonWithMangroves() {
        let absorptionRadius = 1000; // Radius around mangroves that absorbs carbon

        //  Draw Green Glow to Show Absorption Area 
        mangrovePositions.forEach(mangrove => {
            simCtx.fillStyle = "rgba(0, 255, 0, 5)";
            simCtx.beginPath();
            simCtx.arc(mangrove.x, mangrove.y, absorptionRadius, 0, Math.PI * 2);
            simCtx.fill();
        });

        //  Filter Carbon Particles That Are Outside the Absorption Area 
        carbonParticles = carbonParticles.filter(particle => {
            let absorbed = mangrovePositions.some(mangrove => {
                let dx = particle.x - mangrove.x;
                let dy = particle.y - mangrove.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                return distance < absorptionRadius; // If inside radius, mark for removal
            });

            return !absorbed; // Keep only particles NOT absorbed
        });

            console.log("Carbon Particles After Absorption:", carbonParticles.length); // Debugging
        }

        function absorbCarbonWithMangroves() {
            let baseAbsorption = 2; // Each mangrove absorbs 2 particles per second (kid-friendly speed)
            let totalAbsorption = mangrovePositions.length * baseAbsorption;

            //  Show a Green Glow Around Mangroves 
            mangrovePositions.forEach(mangrove => {
                simCtx.fillStyle = "rgba(0, 255, 0, 0.3)";
                simCtx.beginPath();
                simCtx.arc(mangrove.x, mangrove.y, 50, 0, Math.PI * 2);
                simCtx.fill();
            });

            //  Gradual Absorption - Only Absorb Some Carbon Each Frame 
            let maxAbsorption = Math.min(totalAbsorption, carbonParticles.length * 0.15); // Up to 15% per frame
            carbonParticles = carbonParticles.slice(maxAbsorption); // Remove absorbed particles

            //  Add a Fun "Bubble Effect" When Carbon is Absorbed 
            for (let i = 0; i < maxAbsorption; i++) {
                let x = Math.random() * simCanvas.width; 
                let y = Math.random() * simCanvas.height;
                absorptionBubbles.push({ x, y, size: Math.random() * 5 + 3, opacity: 1 });
            }

            console.log(`Carbon Particles Left: ${carbonParticles.length}`);
        }

        let absorptionBubbles = []; // Stores "bubbles" from absorbed carbon

        function generateCarbonParticles(vehicles, houses, buildings, population, temp) {
            let mangroveFactor = Math.max(1 - mangrovePositions.length / 100, 0.1); // Reduce emissions if mangroves exist

            let emissionLevels = {
                vehicles: Math.ceil(1.5 * mangroveFactor),   // Vehicles contribute around 25-30%
                houses: Math.ceil(1 * mangroveFactor),     // Houses contribute ~15-20%
                buildings: Math.ceil(4 * mangroveFactor),    // Buildings contribute the most (~40%)
                population: Math.ceil(0.5 * mangroveFactor), // Lower, since individuals emit less
                seaTemp: Math.ceil((temp - 20) * 2 * mangroveFactor) // Increased for greater effect
            };

            //  Generate Carbon Emissions with Reduced Effect 
            carPositions.forEach(car => {
                for (let i = 0; i < emissionLevels.vehicles; i++) {
                    if (Math.random() < 0.3) { // 50% chance per vehicle to emit
                        carbonParticles.push(createCarbonParticle(car.x + 10, car.y));
                    }
                }
            });

            buildingPositions.forEach(building => {
                for (let i = 0; i < emissionLevels.buildings; i++) {
                    if (Math.random() < 0.5) { // 30% chance per building to emit
                        carbonParticles.push(createCarbonParticle(building.x + 20, building.y));
                    }
                }
            });

            housePositions.forEach(house => {
                for (let i = 0; i < emissionLevels.houses; i++) {
                    if (Math.random() < 0.25) { // 20% chance per house to emit
                        carbonParticles.push(createCarbonParticle(house.x + 15, house.y));
                    }
                }
            });

            peoplePositions.forEach(person => {
                for (let i = 0; i < emissionLevels.population; i++) {
                    if (Math.random() < 0.02) { // 2% chance per person to emit
                        carbonParticles.push(createCarbonParticle(person.x, person.y));
                    }
                }
            });

            if (temp > 22) {
                let fixedX = simCanvas.width * 0.001;  // Adjust this for column position

                for (let i = 0; i < emissionLevels.seaTemp; i++) {
                    if (Math.random() < 0.2) { // 40% chance per sea temp level to emit
                        carbonParticles.push(createCarbonParticle(
                            fixedX,  // Keep x constant for vertical column
                            simCanvas.height - (Math.random() * 500)  // Vary y for vertical spread
                        ));
                    }
                }
            }

        }

        function createCarbonParticle(x, y) {
            return {
                x: x,
                y: y,
                size: Math.random() * 4 + 2, // Random size between 2-6 pixels
                speed: Math.random() * 0.5 + 0.3, // Slower, smooth floating
                opacity: 1, // Start fully visible
                drift: Math.random() * 2 - 1, // Slight left-right movement
                curve: Math.random() * 0.05 // Creates a gentle wave effect
            };
        }


        function drawCarbonParticles() {
            if (!carbonParticles || carbonParticles.length === 0) return;

            simCtx.fillStyle = "rgba(50, 50, 50, 1)"; // Dark gray for carbon particles

            carbonParticles.forEach((particle, index) => {
                simCtx.globalAlpha = particle.opacity; // Smooth fade-out effect

                //  Draw carbon particle 
                simCtx.beginPath();
                simCtx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                simCtx.fill();

                //  Smooth floating animation 
                particle.y -= particle.speed; // Move up slowly
                particle.x += Math.sin(particle.y * particle.curve) * 0.5; // Gentle drifting
                particle.opacity -= 0.005; // Slow fade-out

                //  Remove fully faded particles 
                if (particle.opacity <= 0) {
                    carbonParticles.splice(index, 1);
                }
            });

            simCtx.globalAlpha = 1; // Reset opacity for other drawings
}


        //draw mangroves
        let mangrovePositions = [];
        let waveOffsetMangrove = 0; // To animate the movement

        // Initialize Mangroves
        function initializeMangroves(mangrove) {
            let count = Math.floor(mangrove / 1); // Adjust density
            if (mangrovePositions.length !== count) {
                generateMangrovePositions(count);
            }
        }
        
        function drawMangroves(ctx) {
            mangrovePositions.forEach(mangrove => {
                drawMangroveTree(ctx, mangrove.x, mangrove.y);
            });
        }

        // Generate random positions for mangroves in the sea only
        function generateMangrovePositions(count) {
            mangrovePositions = []; // Reset the list
            let seaX = 120; // Start at leftmost part of the sea
            let seaWidth = simCanvas.width * 0.25; // Mangroves can only be in 40% of canvas
            let mangroveSize = 20; // Size of each mangrove
            let buffer = 0; // Prevent overlap
            let maxAttempts = 100; // Avoid infinite loops

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newMangrove;
                let collision;

                do {
                    let mangroveX = seaX + Math.random() * (seaWidth - mangroveSize);
                    let mangroveY = Math.random() * (simCanvas.height - mangroveSize);

                    newMangrove = { x: mangroveX, y: mangroveY };

                    // Check for collision with other mangroves
                    collision = mangrovePositions.some(mangrove => 
                        checkCollision(mangrove, newMangrove, mangroveSize, mangroveSize, buffer)
                    );

                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    mangrovePositions.push(newMangrove);
                }
            }
        }


        // Draw a mangrove tree
        function drawMangroveTree(ctx, x, y) {
            let treeHeight = 25;  // Reduced height
            let trunkWidth = 3;   // Thinner trunk
            let canopyRadius = 10; // Smaller canopy

            // Animate sway effect
            let sway = Math.sin(waveOffsetMangrove * 0.1) * 2; // Slight movement effect

            // **Draw roots**
            ctx.strokeStyle = "brown";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x, y + treeHeight); // Base of trunk
            ctx.lineTo(x - 3, y + treeHeight + 5 + sway);
            ctx.moveTo(x, y + treeHeight);
            ctx.lineTo(x + 3, y + treeHeight + 6 - sway);
            ctx.stroke();

            // **Draw trunk**
            ctx.fillStyle = "brown";
            ctx.fillRect(x - trunkWidth / 2, y, trunkWidth, treeHeight);

            // **Draw canopy (green swaying leaves)**
            ctx.fillStyle = "#2E8B57"; // Dark green
            ctx.beginPath();
            ctx.arc(x + sway, y - 6, canopyRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "#4CAF50"; // Lighter green for depth
            ctx.beginPath();
            ctx.arc(x - 3 + sway, y - 8, canopyRadius * 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        //  Animate Mangroves 
        function animateMangroves() {
            waveOffsetMangrove += 1; // Move the wave effect
            requestAnimationFrame(animateMangroves); // Loop animation
        }

        // Start animation loop for mangroves
        animateMangroves();

        //draw building
        let buildingPositions = [];
        function initializeBuilding(buildings) {
            let count = Math.floor(buildings / 1);
            if (buildingPositions.length !== count) {
                generateBuildingPositions(count);
            }
        }

        function drawBuilding(ctx) {
            buildingPositions.forEach(building => {
                let buildingWidth = 25; // Reduced width
                let buildingHeight = 80; // Reduced height

                // Draw building body
                ctx.fillStyle = "gray";
                ctx.fillRect(building.x, building.y, buildingWidth, buildingHeight);

                // Draw building outline
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.strokeRect(building.x, building.y, buildingWidth, buildingHeight);

                // Draw windows
                ctx.fillStyle = "lightblue"; 
                let windowWidth = 6, windowHeight = 6;
                let gapX = 4, gapY = 10; // Adjusted spacing

                for (let row = 0; row < 2; row++) { // 2 rows of windows
                    for (let col = 0; col < 2; col++) { // 2 columns of windows
                        let windowX = building.x + gapX + col * (windowWidth + 6);
                        let windowY = building.y + gapY + row * (windowHeight + 10);
                        ctx.fillRect(windowX, windowY, windowWidth, windowHeight);
                        ctx.strokeRect(windowX, windowY, windowWidth, windowHeight);
                    }
                }

                // Draw door
                ctx.fillStyle = "brown";
                let doorWidth = 10, doorHeight = 15;
                let doorX = building.x + (buildingWidth - doorWidth) / 2; // Center door
                let doorY = building.y + buildingHeight - doorHeight;
                ctx.fillRect(doorX, doorY, doorWidth, doorHeight);
                ctx.strokeRect(doorX, doorY, doorWidth, doorHeight);
            });
        }

        function generateBuildingPositions(count) {
            buildingPositions = []; // Reset list
            let landX = (simCanvas.width - 200) / 2 + 200; // Land starts here
            let landWidth = simCanvas.width - landX;
            let buildingWidth = 25;  
            let buildingHeight = 80; 
            let buffer = 5; // Avoid overlap
            let maxAttempts = 100;

            let landY = 50; // Ensure buildings start higher up
            let landHeight = simCanvas.height - landY - buildingHeight - buffer; 

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newBuilding;
                let collision;

                do {
                    let buildingX = landX + Math.random() * (landWidth - buildingWidth - buffer);
                    let buildingY = landY + Math.random() * (landHeight - buffer); // Spread across land

                    newBuilding = { x: buildingX, y: buildingY };

                    // Check for collision with other buildings
                    collision = buildingPositions.some(building => 
                        checkBuildingCollision(building, newBuilding, buildingWidth, buildingHeight, buffer)
                    );

                    // Check for collision with houses
                    if (!collision) {
                        collision = housePositions.some(house => 
                            checkBuildingCollision(house, newBuilding, buildingWidth, buildingHeight, buffer)
                        );
                    }

                    // Check for collision with people
                    if (!collision) {
                        collision = peoplePositions.some(person =>
                            checkCollision(person, newBuilding, buildingWidth, buildingHeight, buffer)
                        );
                    }

                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    buildingPositions.push(newBuilding);
                }
            }

            buildingPositions.length = count; // Trim extra buildings if count is reduced
        }

        function checkBuildingCollision(a, b, width, height, buffer) {
            return (
                a.x < b.x + width + buffer &&
                a.x + width + buffer > b.x &&
                a.y < b.y + height + buffer &&
                a.y + height + buffer > b.y
            );
        }

        function drawHouses(ctx) {
            housePositions.forEach(house => {
                let houseWidth = 30;  // Increased width slightly
                let houseHeight = 24; // Slightly increased height
                let roofHeight = 14;  // Taller roof
                let brickSize = 4;    // Adjusted brick size for visibility

                // House Body (Brick Wall)
                ctx.fillStyle = "#FF9800";
                ctx.fillRect(house.x, house.y, houseWidth, houseHeight);

                // Draw bricks
                ctx.strokeStyle = "#D2691E";
                ctx.lineWidth = 1.2;
                for (let y = house.y; y < house.y + houseHeight; y += brickSize) {
                    for (let x = house.x; x < house.x + houseWidth; x += brickSize) {
                        let offset = (y % (brickSize * 2) === 0) ? 0 : brickSize / 2 - 1;
                        ctx.strokeRect(x + offset, y, brickSize, brickSize);
                    }
                }

                // Outline for the house
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1.2;
                ctx.strokeRect(house.x, house.y, houseWidth, houseHeight);

                // Roof
                ctx.fillStyle = "#D84315";
                ctx.beginPath();
                ctx.moveTo(house.x, house.y);
                ctx.lineTo(house.x + houseWidth / 2, house.y - roofHeight);
                ctx.lineTo(house.x + houseWidth, house.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Windows
                ctx.fillStyle = "#ADD8E6"; // Light blue glass effect
                let windowSize = 6;
                let windowSpacing = 5;
                ctx.fillRect(house.x + windowSpacing, house.y + 5, windowSize, windowSize);
                ctx.fillRect(house.x + houseWidth - windowSpacing - windowSize, house.y + 5, windowSize, windowSize);
                ctx.strokeRect(house.x + windowSpacing, house.y + 5, windowSize, windowSize);
                ctx.strokeRect(house.x + houseWidth - windowSpacing - windowSize, house.y + 5, windowSize, windowSize);

                // Door
                ctx.fillStyle = "brown";
                let doorWidth = 7, doorHeight = 12;
                let doorX = house.x + (houseWidth - doorWidth) / 2;
                let doorY = house.y + houseHeight - doorHeight;
                ctx.fillRect(doorX, doorY, doorWidth, doorHeight);
                ctx.strokeRect(doorX, doorY, doorWidth, doorHeight);

                // Doorknob
                ctx.fillStyle = "gold";
                ctx.beginPath();
                ctx.arc(doorX + doorWidth - 2, doorY + doorHeight / 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });
        }


        let housePositions = [];
        // Initialize houses
        function initializeHouses(houses) {
            let count = Math.floor(houses / 1); // Adjust density
            if (housePositions.length !== count) {
                generateHousePositions(count);
            }
        }

        function generateHousePositions(count) {
            housePositions = []; // Reset list
            let landX = (simCanvas.width - 200) / 2 + 150; // Land starts here
            let landWidth = simCanvas.width - landX;
            let houseWidth = 30, houseHeight = 25;
            let buffer = 10// Avoid overlap
            let maxAttempts = 100;

            let landY = 50; // Start higher to cover more land
            let landHeight = simCanvas.height - landY - houseHeight - buffer; 

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newHouse;
                let collision;

                do {
                    let houseX = landX + Math.random() * (landWidth - houseWidth - buffer);
                    let houseY = landY + Math.random() * (landHeight - buffer); // Spread across land

                    newHouse = { x: houseX, y: houseY };

                    // Check for collision with other houses
                    collision = housePositions.some(house =>
                        checkCollision(house, newHouse, houseWidth, houseHeight, buffer)
                    );

                    // Check for collision with buildings
                    if (!collision) {
                        collision = buildingPositions.some(building =>
                            checkCollision(building, newHouse, 40, 120, buffer)
                        );
                    }

                    // Check for collision with people
                    if (!collision) {
                        collision = peoplePositions.some(person =>
                            checkCollision(person, newHouse, houseWidth, houseHeight, buffer)
                        );
                    }

                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    housePositions.push(newHouse);
                }
            }
        }
        
        // draw People
        // Call this once when population changes, NOT in updateSimulation
        function initializePeople(population) {
            let count = Math.floor(population / 1);
            if (peoplePositions.length !== count) {
                generatePeoplePositions(count);
            }
        }

        function drawPeople(ctx) {
            peoplePositions.forEach(person => {
                // Draw Head (Smaller Circle)
                ctx.fillStyle = person.headColor;
                ctx.beginPath();
                ctx.arc(person.x, person.y, 3, 0, Math.PI * 2); // Reduced size
                ctx.fill();

                // Draw Body (Smaller Rectangle)
                ctx.fillStyle = person.shirtColor;
                ctx.fillRect(person.x - 3, person.y + 5, 6, 10); // Reduced width & height

                // Draw Legs (Smaller Rectangles)
                ctx.fillStyle = person.pantsColor;
                ctx.fillRect(person.x - 3, person.y + 15, 2, 6); // Thinner legs
                ctx.fillRect(person.x + 1, person.y + 15, 2, 6);
            });
        }


        let peoplePositions = [];

        function generatePeoplePositions(count) {
            peoplePositions = []; // Reset list
            let landX = (simCanvas.width - 200) / 2 + 150; // Land starts here
            let landWidth = simCanvas.width - landX;
            let personSize = 20;
            let buffer = 10; // Avoid overlap
            let maxAttempts = 100;

            // Define color options
            const headColors = ["#FDD835", "#FFCCBC", "#FFC107", "#D4A373"];
            const shirtColors = ["#9C27B0", "#1976D2", "#388E3C", "#FF5722", "#E91E63"];
            const pantsColors = ["black", "navy", "gray", "brown", "#795548"];


            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newPerson;
                let collision;

                do {
                    let personX = landX + Math.random() * (landWidth - personSize);
                    let personY = Math.random() * (simCanvas.height - personSize);
                    newPerson = { x: personX, y: personY };

                    // Assign random colors  once  when generating the person
                    let headColor = headColors[Math.floor(Math.random() * headColors.length)];
                    let shirtColor = shirtColors[Math.floor(Math.random() * shirtColors.length)];
                    let pantsColor = pantsColors[Math.floor(Math.random() * pantsColors.length)];
                    
                    newPerson = { 
                        x: personX, 
                        y: personY,
                        headColor: headColor, 
                        shirtColor: shirtColor, 
                        pantsColor: pantsColor 
                    };

                    // Check collision with other people
                    collision = peoplePositions.some(person => 
                        checkCollision(person, newPerson, personSize, personSize, buffer)
                    );

                    // Check collision with buildings
                    if (!collision) {
                        collision = buildingPositions.some(building => 
                            checkCollision(
                                building, 
                                newPerson, 
                                40, // Building width
                                120, // Building height
                                buffer
                            )
                        );
                    }

                    // Check collision with houses
                    if (!collision) {
                        collision = housePositions.some(house => 
                            checkCollision(
                                house, 
                                newPerson, 
                                40, // House width (assuming it's the same as in generateHousePositions)
                                30, // House height
                                buffer
                            )
                        );
                    }

                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    peoplePositions.push(newPerson);
                }
            }
        }

        //  Generalized function to check collisions between two rectangular objects 
        function checkCollision(obj1, obj2, obj1Width, obj1Height, buffer) {
            return (
                obj1.x < obj2.x + obj1Width + buffer &&
                obj1.x + obj1Width + buffer > obj2.x &&
                obj1.y < obj2.y + obj1Height + buffer &&
                obj1.y + obj1Height + buffer > obj2.y
            );
        }
                
        //check collision for people only 
        function checkPersonCollision(person1, person2, width, height, buffer) {
            return (
                person1.x < person2.x + width + buffer &&
                person1.x + width + buffer > person2.x &&
                person1.y < person2.y + height + buffer &&
                person1.y + height + buffer > person2.y
            );
        }

        // Call initializePeople() once at the start or when population changes
        initializePeople();

        //draw road
        function drawRoad(){
            // Draw Road (Centered)
            simCtx.fillStyle = "#707070";
            let roadWidth = 120;
            let roadX = (simCanvas.width - roadWidth) / 2 - 50;
            simCtx.fillRect(roadX, 0, roadWidth, simCanvas.height);

            // Draw Lane Markings
            simCtx.strokeStyle = "white";
            simCtx.lineWidth = 5;
            simCtx.setLineDash([20, 20]); // Dashed lines
            simCtx.beginPath();
            simCtx.moveTo(roadX + roadWidth / 2, 0);
            simCtx.lineTo(roadX + roadWidth / 2, simCanvas.height);
            simCtx.stroke();
            simCtx.setLineDash([]); // Reset dash style

            // Draw Land (On Top of Road, Right Side)
            simCtx.fillStyle = "#CD853F"; // Brown for land
            let landX = roadX + roadWidth; // Right side of the road
            simCtx.fillRect(landX, 0, simCanvas.width - landX, simCanvas.height);
        }

        //draw car
        function makeCar(vehicles){
            //draw car and initialization of car/vehicle only
            let carCount = Math.floor(vehicles / 1); // Adjust density
            if (carPositions.length !== carCount) {
                generateCarPositions(carCount); // Only update when needed
            }
            carPositions.forEach(car => drawCar(simCtx, car.x, car.y, car.color));
        }

        function drawCar(ctx, x, y, color) { 
            let carWidth = 20;  // Smaller width
            let carHeight = 35; // Smaller height

            // Draw car body
            ctx.fillStyle = color;
            ctx.fillRect(x, y, carWidth, carHeight);  

            // Draw car outline
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, carWidth, carHeight);

            // Roof (Windows Area)
            ctx.fillStyle = "lightblue";
            ctx.fillRect(x + 4, y + 6, carWidth - 8, carHeight - 18);
            ctx.strokeRect(x + 4, y + 6, carWidth - 8, carHeight - 18); // Outline for windows

            // Wheels (Smaller)
            ctx.fillStyle = "black";
            ctx.fillRect(x - 2, y + 2, 5, 8);   // Front-left wheel
            ctx.fillRect(x + carWidth - 3, y + 2, 5, 8);  // Front-right wheel
            ctx.fillRect(x - 2, y + carHeight - 10, 5, 8);  // Rear-left wheel
            ctx.fillRect(x + carWidth - 3, y + carHeight - 10, 5, 8);  // Rear-right wheel

            // Headlights (Front)
            ctx.fillStyle = "yellow";
            ctx.fillRect(x + 5, y - 2, 10, 2);
            ctx.strokeRect(x + 5, y - 2, 10, 2); // Outline for headlights

            // Taillights (Rear)
            ctx.fillStyle = "red";
            ctx.fillRect(x + 5, y + carHeight, 10, 2);
            ctx.strokeRect(x + 5, y + carHeight, 10, 2); // Outline for taillights
        }

        let carPositions = []; // Store car positions
        function generateCarPositions(count) {
            carPositions = []; // Reset the car list
            let roadX = (simCanvas.width - 200) / 2 - 10;
            let roadWidth = 130;
            let carWidth = 30;
            let carHeight = 50;
            let buffer = 10; // Extra space to prevent collisions
            let maxAttempts = 100; // Prevent infinite loops
            let carColors = ["blue", "red"];

            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let newCar;
                let collision;

                do {
                    let carX = roadX + Math.random() * (roadWidth - carWidth);
                    let carY = Math.random() * (simCanvas.height - carHeight);
                    let color = carColors[Math.floor(Math.random() * carColors.length)];
                    newCar = { x: carX, y: carY, color: color };
                    collision = carPositions.some(car => checkCarCollision(car, newCar, carWidth, carHeight, buffer));
                    attempts++;
                } while (collision && attempts < maxAttempts);

                if (!collision) {
                    carPositions.push(newCar);
                }
            }
        }

        function checkCarCollision(car1, car2, carWidth, carHeight, buffer = 0) {
            return (
                car1.x < car2.x + carWidth + buffer &&
                car1.x + carWidth + buffer > car2.x &&
                car1.y < car2.y + carHeight + buffer &&
                car1.y + carHeight + buffer > car2.y
            );
        }

        //sea drawing
        let waveOffset = 0;
        let smallWaves = [];
        // let heatBubbles = [];

        function drawSea() {
            //  Get current sea temperature from the slider 
            seaTemp = parseFloat(document.getElementById('temp').value) || 20;

            //  Adjust sea color dynamically 
            let blueTone = Math.max(150, 213 - (seaTemp - 20) * 10); // Cooler sea = lighter, hotter = darker
            let seaColor = `rgb(${Math.min(163 + (seaTemp - 20) * 5, 255)}, ${blueTone}, 255)`;
            simCtx.fillStyle = seaColor;
            simCtx.fillRect(0, 0, simCanvas.width * 0.4, simCanvas.height);

            //  Wave Motion Settings 
            let amplitude = 15 + (seaTemp - 20) * 1 - 10; // Higher temp = stronger waves
            let frequency = 0.02;
            let numWaves = 5;

            //  Main Wave Effect 
            simCtx.fillStyle = '#4da6ff';
            simCtx.beginPath();
            for (let i = 0; i < numWaves; i++) {
                let phase = i * Math.PI / numWaves;
                simCtx.moveTo(0, 0);
                for (let y = 0; y <= simCanvas.height; y += 5) {
                    let waveX = Math.sin((y + waveOffset + phase) * frequency) * amplitude + 100;
                    simCtx.lineTo(waveX, y);
                }
                simCtx.lineTo(0, simCanvas.height);
            }
            simCtx.closePath();
            simCtx.fill();

            //  Small Random Waves Near Shore 
            simCtx.fillStyle = '#ffffff'; // White for foam effect
            smallWaves.forEach((wave, index) => {
                simCtx.beginPath();
                simCtx.arc(wave.x, wave.y, wave.size, 0, Math.PI * 2);
                simCtx.fill();
                wave.x += wave.speed; // Move toward shore
                wave.y += Math.sin(waveOffset * 0.1) * 0.5;

                // Remove wave if it reaches shoreline
                if (wave.x > simCanvas.width * 0.3) {
                    smallWaves.splice(index, 1);
                }
            });

            //  Generate Tiny Waves Randomly 
            if (Math.random() < 0.02) {
                smallWaves.push({
                    x: simCanvas.width * 0.2,
                    y: Math.random() * simCanvas.height,
                    size: Math.random() * 4 + 2, // Tiny wave size
                    speed: Math.random() * 0.8 + 0.3 // Random speed
                });
            }

            waveOffset += 1; // Animate waves

            //  Draw Shoreline LAST so it's always on top 
            drawShoreline();
        }

        function drawShoreline() {
            //  Fixed Shoreline Color (Does NOT change with temperature) 
            simCtx.fillStyle = '#c2a772'; // Permanent sand color

            simCtx.beginPath();
            for (let y = 0; y <= simCanvas.height; y += 10) {
                let shorelineX = simCanvas.width * 0.26 + Math.sin((y + waveOffset) * 0.02) * 8 + 100;
                simCtx.lineTo(shorelineX, y);
            }
            simCtx.lineTo(simCanvas.width * 15, simCanvas.height);
            simCtx.lineTo(simCanvas.width * 0.4, 0);
            simCtx.closePath();
            simCtx.fill();
        }

        function animate() {
            waveOffset += 1; // Move the wave
            updateSimulation(); // Redraw the whole simulation
            requestAnimationFrame(animate); // Loop animation
        }

        // Start animation loop for sea waves
        animate();
        updateSimulation();
    </script>
</body>
</html>